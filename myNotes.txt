This Terminal command connects to the database:
psql "postgres://tavo:@localhost:5432/chirpy"
The string is the connection string for the database.


To migrate the database up/down using goose, navigate to sql/schema folder and use command:
goose postgres "postgres://tavo:@localhost:5432/chirpy" up


Remember you need to add Google's uuid package manually by running:
go get github.com/google/uuid
As well as a Postgres driver! So program knows how to talk to the database:
go get github.com/lib/pq
Used by adding this to the top of main.go :
import _ "github.com/lib/pq"
Not used directly in the code. Underscore tells Go that it's importing it for
its side effects, not because you need to use it.

Remember to add a .env file at the root with contents below. Ther reason
being that this is a local database and as such there's no SSL certificates:
DB_URL="postgres://tavo:@localhost:5432/chirpy?sslmode=disable"
Then run:
go get github.com/joho/godotenv
Then call godotenv.Load() at the beginning of main() to load the .env file
into the environment variables.
Then you can use os.Getenv to get the DB_URL from the environment.



---- Notes on tokens ----
What's a token?
- A token is a small signed string the server gives a client after login.
- It proves “who you are” without sending your password each time.
- The server signs it (e.g., with HMAC) so clients can’t tamper with its contents.
- Clients send it on each request (usually in the Authorization header) so the server can authorize actions.

JWTs (JSON Web Tokens)
- A common token format: three base64url parts (header, payload, signature).
- Payload holds claims like subject (user ID), issuer, issued-at, expiry.
- Signature proves the payload hasn’t been changed.

Access tokens vs. refresh tokens

Access token:
- Short-lived (minutes).
- Used on every API request.
- If stolen, damage is limited by short expiry.

Refresh token:
- Longer-lived (days/weeks).
- Used only to get a new access token when the old one expires.
- Never sent on normal API calls (only to the token-refresh endpoint).
- Often stored more securely (e.g., HTTP-only cookie) and guarded tightly.

Why both?
Security + usability. Short-lived access tokens reduce risk;
refresh tokens let users stay logged in without re-entering
credentials constantly.

Typical flow
1. User logs in with password.
2. Server issues:
   - Access token (e.g., issuer=chirpy-access, exp=15m)
   - Refresh token (e.g., issuer=chirpy-refresh, exp=7d)
3. Client calls APIs with the access token.
4. When it expires, client sends the refresh token to get a new access token.
5. Server can revoke refresh tokens server-side
   (e.g., store IDs, rotate, or blacklist).

Best practices (starter set)
- Keep access tokens short-lived.
- Don’t use refresh tokens on every request; only at refresh endpoints.
- Validate issuer, expiry, and audience.
- Consider rotation: issue a new refresh token on each refresh and invalidate the old one.
- Store secrets safely; use HTTPS.




